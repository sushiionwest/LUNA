/*!\n * Luna Comprehensive Integration Tests\n */\n\nuse std::time::Duration;\nuse image::{ImageBuffer, Rgb, RgbImage};\nuse luna::ai::{CLIPModel, AICoordinator, ElementDetection};\nuse luna::core::{SafetySystem, LunaConfig, LunaAction};\n\n#[cfg(test)]\nmod ai_tests {\n    use super::*;\n    use luna::ai::model_manager::ModelManager;\n    use std::sync::Arc;\n\n    #[tokio::test]\n    async fn test_ai_coordinator_initialization() {\n        let result = AICoordinator::new().await;\n        assert!(result.is_ok(), \"AI coordinator should initialize successfully\");\n        \n        let coordinator = result.unwrap();\n        // Test that coordinator has loaded models\n        assert!(coordinator.vision_models.len() > 0, \"Should have vision models loaded\");\n    }\n\n    #[tokio::test]\n    async fn test_clip_model_creation() {\n        let model_manager = Arc::new(ModelManager::new().await.expect(\"Model manager creation failed\"));\n        let result = CLIPModel::new(&model_manager).await;\n        \n        assert!(result.is_ok(), \"CLIP model should create successfully\");\n        let clip = result.unwrap();\n        assert!(clip.is_loaded(), \"CLIP model should be loaded\");\n    }\n\n    #[tokio::test]\n    async fn test_screen_analysis_with_mock_image() {\n        let model_manager = Arc::new(ModelManager::new().await.expect(\"Model manager failed\"));\n        let clip = CLIPModel::new(&model_manager).await.expect(\"CLIP creation failed\");\n        \n        // Create a test image with some UI-like elements\n        let test_image = create_test_ui_image();\n        \n        let result = clip.analyze_screen(&test_image.into());\n        assert!(result.is_ok(), \"Screen analysis should succeed\");\n        \n        let elements = result.unwrap();\n        assert!(!elements.is_empty(), \"Should detect UI elements in test image\");\n        \n        // Verify detected elements have reasonable properties\n        for element in &elements {\n            assert!(element.confidence > 0.0, \"Element confidence should be positive\");\n            assert!(element.confidence <= 1.0, \"Element confidence should be <= 1.0\");\n            assert!(!element.element_type.is_empty(), \"Element type should not be empty\");\n        }\n    }\n\n    #[tokio::test]\n    async fn test_text_detection() {\n        let model_manager = Arc::new(ModelManager::new().await.expect(\"Model manager failed\"));\n        let clip = CLIPModel::new(&model_manager).await.expect(\"CLIP creation failed\");\n        \n        let test_image = create_test_ui_image();\n        let result = clip.detect_text(&test_image.into());\n        \n        assert!(result.is_ok(), \"Text detection should succeed\");\n        let text = result.unwrap();\n        assert!(!text.is_empty(), \"Should detect some text content\");\n    }\n\n    #[tokio::test]\n    async fn test_element_finding() {\n        let model_manager = Arc::new(ModelManager::new().await.expect(\"Model manager failed\"));\n        let clip = CLIPModel::new(&model_manager).await.expect(\"CLIP creation failed\");\n        \n        let test_image = create_test_ui_image();\n        \n        // Test finding buttons\n        let result = clip.find_elements(&test_image.into(), \"button\");\n        assert!(result.is_ok(), \"Element finding should succeed\");\n        \n        let buttons = result.unwrap();\n        // Should find at least some button-like elements\n        assert!(!buttons.is_empty(), \"Should find button elements\");\n        \n        // Test finding with different queries\n        let queries = [\"textfield\", \"icon\", \"link\"];\n        for query in &queries {\n            let result = clip.find_elements(&test_image.into(), query);\n            assert!(result.is_ok(), \"Finding {} should succeed\", query);\n        }\n    }\n\n    #[test]\n    fn test_element_detection_structure() {\n        // Test ElementDetection structure\n        let element = ElementDetection {\n            element_type: \"button\".to_string(),\n            bounds: luna::core::ElementBounds {\n                x: 100,\n                y: 200,\n                width: 80,\n                height: 30,\n            },\n            confidence: 0.85,\n            text: Some(\"Click Me\".to_string()),\n            attributes: std::collections::HashMap::new(),\n        };\n        \n        assert_eq!(element.element_type, \"button\");\n        assert_eq!(element.confidence, 0.85);\n        assert_eq!(element.text, Some(\"Click Me\".to_string()));\n    }\n\n    fn create_test_ui_image() -> RgbImage {\n        let mut image = ImageBuffer::new(800, 600);\n        \n        // Fill with light background\n        for pixel in image.pixels_mut() {\n            *pixel = Rgb([240, 240, 240]);\n        }\n        \n        // Create button-like rectangles with borders\n        create_ui_element(&mut image, 100, 100, 120, 40, Rgb([220, 220, 220]), Rgb([100, 100, 100]));\n        create_ui_element(&mut image, 300, 150, 200, 30, Rgb([255, 255, 255]), Rgb([128, 128, 128]));\n        create_ui_element(&mut image, 50, 200, 32, 32, Rgb([180, 180, 255]), Rgb([80, 80, 80]));\n        \n        image\n    }\n}\n\n#[cfg(test)]\nmod safety_tests {\n    use super::*;\n    use luna::core::enhanced_patterns::{check_enhanced_patterns, KeywordThreatAnalyzer};\n\n    #[test]\n    fn test_safety_system_initialization() {\n        let config = LunaConfig::default();\n        let safety = SafetySystem::new(&config);\n        \n        assert!(safety.is_enabled(), \"Safety system should be enabled by default\");\n        \n        let stats = safety.get_stats();\n        assert!(stats.blocked_patterns_count > 0, \"Should have blocked patterns loaded\");\n        assert!(stats.safe_apps_count > 0, \"Should have safe apps configured\");\n    }\n\n    #[test]\n    fn test_dangerous_command_blocking() {\n        let config = LunaConfig::default();\n        let safety = SafetySystem::new(&config);\n        \n        let dangerous_commands = vec![\n            \"rm -rf /\",\n            \"del /s /q C:\\\\\",\n            \"format C: /q\",\n            \"shutdown /s /t 0\",\n            \"reg delete HKEY_LOCAL_MACHINE\",\n        ];\n        \n        for cmd in dangerous_commands {\n            assert!(!safety.is_command_safe(cmd), \"Dangerous command should be blocked: {}\", cmd);\n        }\n    }\n\n    #[test]\n    fn test_safe_command_allowing() {\n        let config = LunaConfig::default();\n        let safety = SafetySystem::new(&config);\n        \n        let safe_commands = vec![\n            \"click the save button\",\n            \"type hello world\",\n            \"press ctrl+c\",\n            \"scroll down\",\n            \"open notepad\",\n        ];\n        \n        for cmd in safe_commands {\n            assert!(safety.is_command_safe(cmd), \"Safe command should be allowed: {}\", cmd);\n        }\n    }\n\n    #[test]\n    fn test_enhanced_pattern_detection() {\n        let test_cases = vec![\n            (\"rm -rf /\", true),\n            (\"format C:\", true),\n            (\"sudo rm file.txt\", true),\n            (\"ls -la\", false),\n            (\"git status\", false),\n        ];\n        \n        for (command, should_detect) in test_cases {\n            let result = check_enhanced_patterns(command);\n            if should_detect {\n                assert!(result.is_some(), \"Should detect dangerous pattern in: {}\", command);\n            } else {\n                assert!(result.is_none(), \"Should not detect pattern in safe command: {}\", command);\n            }\n        }\n    }\n\n    #[test]\n    fn test_keyword_threat_analysis() {\n        let analyzer = KeywordThreatAnalyzer::new();\n        \n        // Test critical keywords\n        let critical_texts = vec![\n            \"enter your password\",\n            \"delete admin credentials\",\n            \"format system drive\",\n        ];\n        \n        for text in critical_texts {\n            let result = analyzer.analyze_keywords(text);\n            assert!(result.threat_level >= luna::core::enhanced_patterns::ThreatLevel::High, \n                    \"Should detect high threat in: {}\", text);\n        }\n        \n        // Test safe text\n        let safe_texts = vec![\n            \"click the button\",\n            \"open the file\",\n            \"save document\",\n        ];\n        \n        for text in safe_texts {\n            let result = analyzer.analyze_keywords(text);\n            assert_eq!(result.threat_level, luna::core::enhanced_patterns::ThreatLevel::Low,\n                      \"Should not detect threat in safe text: {}\", text);\n        }\n    }\n\n    #[test]\n    fn test_action_safety_validation() {\n        let config = LunaConfig::default();\n        let safety = SafetySystem::new(&config);\n        \n        let actions = vec![\n            LunaAction::Click { x: 500, y: 300 },\n            LunaAction::Type { text: \"Hello World\".to_string() },\n            LunaAction::KeyCombo { keys: vec![\"ctrl\".to_string(), \"c\".to_string()] },\n            LunaAction::Wait { milliseconds: 1000 },\n        ];\n        \n        assert!(safety.are_actions_safe(&actions), \"Safe actions should be allowed\");\n        \n        // Test dangerous actions\n        let dangerous_actions = vec![\n            LunaAction::Type { text: \"rm -rf /\".to_string() },\n            LunaAction::KeyCombo { keys: vec![\"ctrl\".to_string(), \"alt\".to_string(), \"del\".to_string()] },\n        ];\n        \n        for action in dangerous_actions {\n            assert!(!safety.is_action_safe(&action), \"Dangerous action should be blocked: {:?}\", action);\n        }\n    }\n}\n\n#[cfg(test)]\nmod performance_tests {\n    use super::*;\n    use std::time::Instant;\n    use luna::ai::model_manager::ModelManager;\n\n    #[tokio::test]\n    async fn test_ai_analysis_performance() {\n        let model_manager = Arc::new(ModelManager::new().await.expect(\"Model manager failed\"));\n        let clip = CLIPModel::new(&model_manager).await.expect(\"CLIP creation failed\");\n        \n        let test_image = create_large_test_image();\n        \n        let start = Instant::now();\n        let result = clip.analyze_screen(&test_image.into());\n        let duration = start.elapsed();\n        \n        assert!(result.is_ok(), \"Analysis should succeed\");\n        assert!(duration.as_millis() < 5000, \"Analysis should complete within 5 seconds, took: {:?}\", duration);\n        \n        let elements = result.unwrap();\n        assert!(elements.len() <= 50, \"Should not detect excessive elements: {}\", elements.len());\n    }\n\n    #[test]\n    fn test_safety_check_performance() {\n        let config = LunaConfig::default();\n        let safety = SafetySystem::new(&config);\n        \n        let test_commands = vec![\n            \"click the save button\",\n            \"type some text\",\n            \"press enter\",\n            \"open file dialog\",\n            \"close window\",\n        ];\n        \n        let start = Instant::now();\n        \n        for _ in 0..1000 {\n            for cmd in &test_commands {\n                let _ = safety.is_command_safe(cmd);\n            }\n        }\n        \n        let duration = start.elapsed();\n        assert!(duration.as_millis() < 1000, \"5000 safety checks should complete within 1 second, took: {:?}\", duration);\n    }\n\n    fn create_large_test_image() -> RgbImage {\n        let mut image = ImageBuffer::new(1920, 1080);\n        \n        // Fill with background\n        for pixel in image.pixels_mut() {\n            *pixel = Rgb([200, 200, 200]);\n        }\n        \n        // Add many UI elements for performance testing\n        for i in 0..30 {\n            let x = (i * 60) % 1800;\n            let y = (i * 50) % 1000;\n            let width = 50 + (i % 3) * 20;\n            let height = 30 + (i % 2) * 15;\n            \n            create_ui_element(&mut image, x, y, width, height, Rgb([240, 240, 240]), Rgb([100, 100, 100]));\n        }\n        \n        image\n    }\n}\n\n#[cfg(test)]\nmod error_handling_tests {\n    use super::*;\n    use luna::ai::model_manager::ModelManager;\n\n    #[tokio::test]\n    async fn test_ai_with_invalid_images() {\n        let model_manager = Arc::new(ModelManager::new().await.expect(\"Model manager failed\"));\n        let clip = CLIPModel::new(&model_manager).await.expect(\"CLIP creation failed\");\n        \n        // Test with minimal image\n        let tiny_image = ImageBuffer::new(1, 1);\n        let result = clip.analyze_screen(&tiny_image.into());\n        assert!(result.is_ok(), \"Should handle tiny images gracefully\");\n        \n        // Test with empty-content image\n        let empty_image = ImageBuffer::from_pixel(10, 10, Rgb([128, 128, 128]));\n        let result = clip.analyze_screen(&empty_image.into());\n        assert!(result.is_ok(), \"Should handle uniform images gracefully\");\n    }\n\n    #[test]\n    fn test_safety_system_edge_cases() {\n        let config = LunaConfig::default();\n        let safety = SafetySystem::new(&config);\n        \n        // Test with empty command\n        assert!(safety.is_command_safe(\"\"), \"Should allow empty commands\");\n        \n        // Test with very long command\n        let long_command = \"a\".repeat(10000);\n        let result = safety.is_command_safe(&long_command);\n        assert!(result == true || result == false, \"Should handle long commands without crashing\");\n        \n        // Test with special characters\n        let special_chars = \"!@#$%^&*()_+-=[]{}|;':.,<>?\";\n        assert!(safety.is_command_safe(special_chars), \"Should handle special characters\");\n    }\n}\n\n// Helper function for creating UI elements in tests\nfn create_ui_element(\n    image: &mut RgbImage, \n    x: u32, \n    y: u32, \n    width: u32, \n    height: u32, \n    fill_color: Rgb<u8>, \n    border_color: Rgb<u8>\n) {\n    let (img_width, img_height) = image.dimensions();\n    \n    for dy in 0..height {\n        for dx in 0..width {\n            let px = x + dx;\n            let py = y + dy;\n            \n            if px < img_width && py < img_height {\n                let color = if dx == 0 || dx == width - 1 || dy == 0 || dy == height - 1 {\n                    border_color\n                } else {\n                    fill_color\n                };\n                image.put_pixel(px, py, color);\n            }\n        }\n    }\n}