/*!\n * Enhanced Safety System Patterns - Advanced threat detection\n */\n\nuse regex::Regex;\nuse std::collections::HashMap;\nuse lazy_static::lazy_static;\nuse crate::core::safety::SafetyResult;\n\n/// Risk levels for different threats\n#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\npub enum ThreatLevel {\n    Low,\n    Medium,\n    High,\n    Critical,\n}\n\n/// Enhanced dangerous patterns with categorization\npub struct EnhancedPatterns {\n    critical: Vec<(Regex, &'static str)>,\n    high: Vec<(Regex, &'static str)>,\n    medium: Vec<(Regex, &'static str)>,\n}\n\nlazy_static! {\n    static ref ENHANCED_PATTERNS: EnhancedPatterns = EnhancedPatterns::new();\n}\n\nimpl EnhancedPatterns {\n    pub fn new() -> Self {\n        Self {\n            critical: Self::init_critical_patterns(),\n            high: Self::init_high_patterns(),\n            medium: Self::init_medium_patterns(),\n        }\n    }\n\n    /// Critical patterns that should never be allowed\n    fn init_critical_patterns() -> Vec<(Regex, &'static str)> {\n        let patterns = vec![\n            // System destruction\n            (r\"rm\\s+-rf\\s+/\", \"Root filesystem deletion attempt\"),\n            (r\"del\\s+/s\\s+/q\\s+[A-Z]:\\\\\", \"Windows drive deletion attempt\"),\n            (r\"format\\s+[A-Z]:\\s*/q\", \"Drive formatting attempt\"),\n            (r\"dd\\s+if=/dev/zero\\s+of=\", \"Disk wiping attempt\"),\n            \n            // System shutdown/restart with force\n            (r\"shutdown\\s+.*(/s|/r|/h)\", \"System shutdown command\"),\n            (r\"halt\\s+|reboot\\s+|poweroff\\s+\", \"System power control\"),\n            \n            // Registry manipulation\n            (r\"reg\\s+delete\\s+HKEY_LOCAL_MACHINE\", \"System registry deletion\"),\n            (r\"reg\\s+delete\\s+HKEY_CURRENT_USER\", \"User registry deletion\"),\n            (r\"regedit\\s+/s\\s+.*\\.reg\", \"Registry import without confirmation\"),\n            \n            // Critical process termination\n            (r\"taskkill\\s+/f\\s+/im\\s+(explorer|winlogon|csrss|lsass)\\.exe\", \"Critical process termination\"),\n            (r\"kill\\s+-9\\s+1\", \"Init process termination\"),\n            (r\"pkill\\s+-9\\s+(init|systemd)\", \"System process termination\"),\n            \n            // Network security bypass\n            (r\"iptables\\s+.*DROP\\s+.*\", \"Firewall rule deletion\"),\n            (r\"netsh\\s+.*delete\\s+.*\", \"Network configuration deletion\"),\n            (r\"route\\s+delete\\s+0\\.0\\.0\\.0\", \"Default route deletion\"),\n            \n            // File system permissions\n            (r\"chmod\\s+000\\s+/\", \"Root permissions removal\"),\n            (r\"chown\\s+.*:\\s*/\", \"Root ownership change\"),\n            \n            // Boot system files\n            (r\"(rm|del|move)\\s+.*boot\\.(ini|cfg)\", \"Boot configuration deletion\"),\n            (r\"(rm|del|move)\\s+.*bootmgr\", \"Boot manager deletion\"),\n            (r\"(rm|del|move)\\s+.*ntldr\", \"NT loader deletion\"),\n        ];\n\n        patterns.into_iter()\n            .filter_map(|(p, desc)| Regex::new(p).ok().map(|r| (r, desc)))\n            .collect()\n    }\n\n    /// High-risk patterns\n    fn init_high_patterns() -> Vec<(Regex, &'static str)> {\n        let patterns = vec![\n            // Credential access\n            (r\"(cat|type|more)\\s+.*shadow\", \"Shadow file access\"),\n            (r\"(cat|type|more)\\s+.*passwd\", \"Password file access\"),\n            (r\"(cat|type|more)\\s+.*\\.key\", \"Private key access\"),\n            (r\"(cat|type|more)\\s+.*credentials\", \"Credentials file access\"),\n            \n            // Privilege escalation\n            (r\"sudo\\s+.*\", \"Elevated command execution\"),\n            (r\"su\\s+-\\s+root\", \"Root user switch\"),\n            (r\"runas\\s+/user:administrator\", \"Administrator execution\"),\n            \n            // Package management (potentially dangerous)\n            (r\"(apt|yum|dnf)\\s+remove\\s+.*\", \"System package removal\"),\n            (r\"pip\\s+uninstall\\s+.*\", \"Python package removal\"),\n            (r\"npm\\s+uninstall\\s+-g\\s+.*\", \"Global npm package removal\"),\n            \n            // Service manipulation\n            (r\"systemctl\\s+(stop|disable)\\s+.*\", \"System service control\"),\n            (r\"service\\s+.*\\s+stop\", \"Service termination\"),\n            (r\"net\\s+stop\\s+.*\", \"Windows service stop\"),\n            \n            // Firewall changes\n            (r\"ufw\\s+(deny|delete)\", \"UFW firewall modification\"),\n            (r\"firewall-cmd\\s+.*--remove\", \"Firewall rule removal\"),\n            \n            // Scheduled tasks\n            (r\"crontab\\s+-r\", \"Cron table deletion\"),\n            (r\"schtasks\\s+/delete\", \"Scheduled task deletion\"),\n            \n            // Database operations\n            (r\"DROP\\s+DATABASE\\s+.*\", \"Database deletion\"),\n            (r\"DELETE\\s+FROM\\s+.*\", \"Database record deletion\"),\n            (r\"TRUNCATE\\s+.*\", \"Database table truncation\"),\n        ];\n\n        patterns.into_iter()\n            .filter_map(|(p, desc)| Regex::new(p).ok().map(|r| (r, desc)))\n            .collect()\n    }\n\n    /// Medium-risk patterns\n    fn init_medium_patterns() -> Vec<(Regex, &'static str)> {\n        let patterns = vec![\n            // File operations\n            (r\"(rm|del)\\s+.*\\.(exe|dll|sys)\", \"System file deletion\"),\n            (r\"move\\s+.*\\s+/dev/null\", \"File disposal\"),\n            (r\"copy\\s+.*\\s+con:\", \"Console redirection\"),\n            \n            // Process monitoring\n            (r\"ps\\s+aux\\s+\\|\\s+grep\\s+.*\", \"Process enumeration\"),\n            (r\"tasklist\\s+/fi\\s+.*\", \"Windows process filtering\"),\n            \n            // Network scanning\n            (r\"nmap\\s+.*\", \"Network scanning\"),\n            (r\"ping\\s+-t\\s+.*\", \"Continuous ping\"),\n            (r\"netstat\\s+-an\", \"Network connection listing\"),\n            \n            // System information gathering\n            (r\"systeminfo\\s+\", \"System information query\"),\n            (r\"wmic\\s+.*\", \"WMI query execution\"),\n            (r\"lscpu\\s+\", \"CPU information query\"),\n            (r\"dmidecode\\s+\", \"Hardware information query\"),\n            \n            // Environment manipulation\n            (r\"set\\s+PATH=\", \"PATH environment modification\"),\n            (r\"export\\s+PATH=\", \"PATH export modification\"),\n            (r\"setx\\s+PATH\\s+.*\", \"Persistent PATH modification\"),\n            \n            // Archive operations\n            (r\"tar\\s+.*--exclude=\", \"Archive creation with exclusions\"),\n            (r\"zip\\s+-r\\s+.*\\s+/\", \"Root directory archiving\"),\n            \n            // Script execution\n            (r\"(bash|sh|cmd|powershell)\\s+-c\\s+.*\", \"Script execution\"),\n            (r\"eval\\s+.*\", \"Dynamic code evaluation\"),\n            (r\"exec\\s+.*\", \"Process replacement\"),\n        ];\n\n        patterns.into_iter()\n            .filter_map(|(p, desc)| Regex::new(p).ok().map(|r| (r, desc)))\n            .collect()\n    }\n\n    /// Check text against all patterns\n    pub fn check_patterns(&self, text: &str) -> Option<PatternMatch> {\n        // Check critical patterns first\n        for (pattern, description) in &self.critical {\n            if pattern.is_match(text) {\n                return Some(PatternMatch {\n                    threat_level: ThreatLevel::Critical,\n                    pattern: pattern.as_str().to_string(),\n                    description: description.to_string(),\n                    matched_text: self.extract_match(pattern, text),\n                });\n            }\n        }\n\n        // Check high-risk patterns\n        for (pattern, description) in &self.high {\n            if pattern.is_match(text) {\n                return Some(PatternMatch {\n                    threat_level: ThreatLevel::High,\n                    pattern: pattern.as_str().to_string(),\n                    description: description.to_string(),\n                    matched_text: self.extract_match(pattern, text),\n                });\n            }\n        }\n\n        // Check medium-risk patterns\n        for (pattern, description) in &self.medium {\n            if pattern.is_match(text) {\n                return Some(PatternMatch {\n                    threat_level: ThreatLevel::Medium,\n                    pattern: pattern.as_str().to_string(),\n                    description: description.to_string(),\n                    matched_text: self.extract_match(pattern, text),\n                });\n            }\n        }\n\n        None\n    }\n\n    /// Extract the matched text from the pattern\n    fn extract_match(&self, pattern: &Regex, text: &str) -> String {\n        pattern.find(text)\n            .map(|m| m.as_str().to_string())\n            .unwrap_or_else(|| \"[Match not found]\".to_string())\n    }\n}\n\n/// Result of pattern matching\n#[derive(Debug, Clone)]\npub struct PatternMatch {\n    pub threat_level: ThreatLevel,\n    pub pattern: String,\n    pub description: String,\n    pub matched_text: String,\n}\n\n/// Check text against dangerous patterns\npub fn check_enhanced_patterns(text: &str) -> Option<PatternMatch> {\n    ENHANCED_PATTERNS.check_patterns(text)\n}\n\n/// Keyword-based threat assessment\npub struct KeywordThreatAnalyzer {\n    critical_keywords: HashMap<String, f32>,\n    high_keywords: HashMap<String, f32>,\n    medium_keywords: HashMap<String, f32>,\n    suspicious_combinations: Vec<(Vec<String>, ThreatLevel, &'static str)>,\n}\n\nimpl Default for KeywordThreatAnalyzer {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nimpl KeywordThreatAnalyzer {\n    pub fn new() -> Self {\n        Self {\n            critical_keywords: Self::init_critical_keywords(),\n            high_keywords: Self::init_high_keywords(),\n            medium_keywords: Self::init_medium_keywords(),\n            suspicious_combinations: Self::init_suspicious_combinations(),\n        }\n    }\n\n    fn init_critical_keywords() -> HashMap<String, f32> {\n        let mut keywords = HashMap::new();\n        \n        // Authentication and security\n        keywords.insert(\"password\".to_string(), 1.0);\n        keywords.insert(\"passwd\".to_string(), 1.0);\n        keywords.insert(\"credential\".to_string(), 1.0);\n        keywords.insert(\"private_key\".to_string(), 1.0);\n        keywords.insert(\"secret_key\".to_string(), 1.0);\n        keywords.insert(\"api_key\".to_string(), 1.0);\n        keywords.insert(\"token\".to_string(), 0.8);\n        keywords.insert(\"certificate\".to_string(), 0.9);\n        \n        // System destruction\n        keywords.insert(\"delete_all\".to_string(), 1.0);\n        keywords.insert(\"remove_all\".to_string(), 1.0);\n        keywords.insert(\"format\".to_string(), 0.9);\n        keywords.insert(\"wipe\".to_string(), 0.9);\n        keywords.insert(\"destroy\".to_string(), 0.8);\n        keywords.insert(\"erase\".to_string(), 0.7);\n        keywords.insert(\"purge\".to_string(), 0.8);\n        \n        // System access\n        keywords.insert(\"administrator\".to_string(), 0.9);\n        keywords.insert(\"admin\".to_string(), 0.8);\n        keywords.insert(\"root\".to_string(), 0.9);\n        keywords.insert(\"sudo\".to_string(), 0.8);\n        keywords.insert(\"elevated\".to_string(), 0.7);\n        keywords.insert(\"privilege\".to_string(), 0.7);\n        keywords.insert(\"superuser\".to_string(), 0.9);\n        \n        keywords\n    }\n\n    fn init_high_keywords() -> HashMap<String, f32> {\n        let mut keywords = HashMap::new();\n        \n        // System files and directories\n        keywords.insert(\"system32\".to_string(), 0.9);\n        keywords.insert(\"windows\".to_string(), 0.6);\n        keywords.insert(\"program_files\".to_string(), 0.7);\n        keywords.insert(\"registry\".to_string(), 0.8);\n        keywords.insert(\"boot\".to_string(), 0.8);\n        keywords.insert(\"kernel\".to_string(), 0.8);\n        \n        // Network and security\n        keywords.insert(\"firewall\".to_string(), 0.7);\n        keywords.insert(\"antivirus\".to_string(), 0.8);\n        keywords.insert(\"security\".to_string(), 0.6);\n        keywords.insert(\"defender\".to_string(), 0.7);\n        keywords.insert(\"encryption\".to_string(), 0.7);\n        \n        // Process and service management\n        keywords.insert(\"service\".to_string(), 0.6);\n        keywords.insert(\"process\".to_string(), 0.5);\n        keywords.insert(\"kill\".to_string(), 0.7);\n        keywords.insert(\"terminate\".to_string(), 0.7);\n        keywords.insert(\"stop\".to_string(), 0.5);\n        keywords.insert(\"disable\".to_string(), 0.6);\n        \n        // Database and data operations\n        keywords.insert(\"database\".to_string(), 0.6);\n        keywords.insert(\"table\".to_string(), 0.4);\n        keywords.insert(\"drop\".to_string(), 0.7);\n        keywords.insert(\"truncate\".to_string(), 0.7);\n        keywords.insert(\"backup\".to_string(), 0.5);\n        \n        keywords\n    }\n\n    fn init_medium_keywords() -> HashMap<String, f32> {\n        let mut keywords = HashMap::new();\n        \n        // File operations\n        keywords.insert(\"file\".to_string(), 0.3);\n        keywords.insert(\"folder\".to_string(), 0.3);\n        keywords.insert(\"directory\".to_string(), 0.3);\n        keywords.insert(\"copy\".to_string(), 0.4);\n        keywords.insert(\"move\".to_string(), 0.4);\n        keywords.insert(\"rename\".to_string(), 0.4);\n        keywords.insert(\"modify\".to_string(), 0.4);\n        \n        // Network operations\n        keywords.insert(\"network\".to_string(), 0.4);\n        keywords.insert(\"internet\".to_string(), 0.3);\n        keywords.insert(\"connection\".to_string(), 0.3);\n        keywords.insert(\"download\".to_string(), 0.4);\n        keywords.insert(\"upload\".to_string(), 0.4);\n        keywords.insert(\"transfer\".to_string(), 0.4);\n        \n        // System information\n        keywords.insert(\"system\".to_string(), 0.4);\n        keywords.insert(\"hardware\".to_string(), 0.3);\n        keywords.insert(\"software\".to_string(), 0.3);\n        keywords.insert(\"version\".to_string(), 0.2);\n        keywords.insert(\"info\".to_string(), 0.2);\n        keywords.insert(\"config\".to_string(), 0.4);\n        \n        keywords\n    }\n\n    fn init_suspicious_combinations() -> Vec<(Vec<String>, ThreatLevel, &'static str)> {\n        vec![\n            // Critical combinations\n            (vec![\"delete\".to_string(), \"system\".to_string()], ThreatLevel::Critical, \"System deletion attempt\"),\n            (vec![\"format\".to_string(), \"drive\".to_string()], ThreatLevel::Critical, \"Drive formatting attempt\"),\n            (vec![\"remove\".to_string(), \"password\".to_string()], ThreatLevel::Critical, \"Password removal attempt\"),\n            \n            // High-risk combinations\n            (vec![\"disable\".to_string(), \"firewall\".to_string()], ThreatLevel::High, \"Firewall disabling\"),\n            (vec![\"stop\".to_string(), \"service\".to_string()], ThreatLevel::High, \"Service stopping\"),\n            (vec![\"access\".to_string(), \"registry\".to_string()], ThreatLevel::High, \"Registry access\"),\n            \n            // Medium-risk combinations\n            (vec![\"copy\".to_string(), \"file\".to_string()], ThreatLevel::Medium, \"File copying\"),\n            (vec![\"modify\".to_string(), \"config\".to_string()], ThreatLevel::Medium, \"Configuration modification\"),\n            (vec![\"download\".to_string(), \"execute\".to_string()], ThreatLevel::Medium, \"Download and execute\"),\n        ]\n    }\n\n    /// Analyze text for keyword-based threats\n    pub fn analyze_keywords(&self, text: &str) -> KeywordThreatAnalysis {\n        let text_lower = text.to_lowercase();\n        let words: Vec<&str> = text_lower.split_whitespace().collect();\n        \n        let mut max_threat_level = ThreatLevel::Low;\n        let mut threat_score = 0.0;\n        let mut detected_keywords = Vec::new();\n        let mut detected_combinations = Vec::new();\n        \n        // Check individual keywords\n        for word in &words {\n            // Critical keywords\n            if let Some(&score) = self.critical_keywords.get(*word) {\n                if score > threat_score {\n                    threat_score = score;\n                    max_threat_level = ThreatLevel::Critical;\n                }\n                detected_keywords.push((word.to_string(), ThreatLevel::Critical, score));\n            }\n            // High keywords\n            else if let Some(&score) = self.high_keywords.get(*word) {\n                if score > threat_score && max_threat_level < ThreatLevel::Critical {\n                    threat_score = score;\n                    max_threat_level = ThreatLevel::High;\n                }\n                detected_keywords.push((word.to_string(), ThreatLevel::High, score));\n            }\n            // Medium keywords\n            else if let Some(&score) = self.medium_keywords.get(*word) {\n                if score > threat_score && max_threat_level < ThreatLevel::High {\n                    threat_score = score;\n                    max_threat_level = ThreatLevel::Medium;\n                }\n                detected_keywords.push((word.to_string(), ThreatLevel::Medium, score));\n            }\n        }\n        \n        // Check suspicious combinations\n        for (combination, level, description) in &self.suspicious_combinations {\n            if combination.iter().all(|keyword| words.iter().any(|word| word.contains(keyword))) {\n                if *level > max_threat_level {\n                    max_threat_level = *level;\n                }\n                detected_combinations.push((combination.clone(), *level, description));\n            }\n        }\n        \n        KeywordThreatAnalysis {\n            threat_level: max_threat_level,\n            threat_score,\n            detected_keywords,\n            detected_combinations,\n        }\n    }\n}\n\n/// Result of keyword threat analysis\n#[derive(Debug, Clone)]\npub struct KeywordThreatAnalysis {\n    pub threat_level: ThreatLevel,\n    pub threat_score: f32,\n    pub detected_keywords: Vec<(String, ThreatLevel, f32)>,\n    pub detected_combinations: Vec<(Vec<String>, ThreatLevel, &'static str)>,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_critical_pattern_detection() {\n        let test_cases = vec![\n            \"rm -rf /\",\n            \"del /s /q C:\\\\\",\n            \"format C: /q\",\n            \"shutdown /s /t 0\",\n            \"reg delete HKEY_LOCAL_MACHINE\",\n        ];\n\n        for case in test_cases {\n            let result = check_enhanced_patterns(case);\n            assert!(result.is_some(), \"Should detect critical pattern: {}\", case);\n            if let Some(pattern_match) = result {\n                assert_eq!(pattern_match.threat_level, ThreatLevel::Critical);\n            }\n        }\n    }\n\n    #[test]\n    fn test_keyword_threat_analysis() {\n        let analyzer = KeywordThreatAnalyzer::new();\n        \n        // Critical keywords\n        let critical_text = \"enter your password\";\n        let result = analyzer.analyze_keywords(critical_text);\n        assert_eq!(result.threat_level, ThreatLevel::Critical);\n        assert!(!result.detected_keywords.is_empty());\n        \n        // Safe text\n        let safe_text = \"click the button\";\n        let result = analyzer.analyze_keywords(safe_text);\n        assert_eq!(result.threat_level, ThreatLevel::Low);\n        \n        // Suspicious combination\n        let combo_text = \"delete system files\";\n        let result = analyzer.analyze_keywords(combo_text);\n        assert!(result.threat_level >= ThreatLevel::Medium);\n    }\n\n    #[test]\n    fn test_safe_commands() {\n        let safe_cases = vec![\n            \"ls -la\",\n            \"cd Documents\",\n            \"echo hello world\",\n            \"git status\",\n            \"npm install\",\n        ];\n\n        for case in safe_cases {\n            let result = check_enhanced_patterns(case);\n            assert!(result.is_none(), \"Should not detect pattern in safe command: {}\", case);\n        }\n    }\n}